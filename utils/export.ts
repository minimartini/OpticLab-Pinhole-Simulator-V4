
import { ApertureConfig, ApertureType, CameraConfig, ExportConfig, ProductionItem, MultiDotPattern } from '../types';

const formatNum = (n: number) => n.toFixed(4).replace(/\.?0+$/, "");

export const generateBlueprintSVG = (
  aperture: ApertureConfig,
  camera: CameraConfig,
  config: ExportConfig
): string => {
  const sizeMm = config.itemSize || Math.max(10, aperture.diameter * 1.5); 
  const center = sizeMm / 2;
  const dateStr = new Date().toISOString();
  
  const content = getAperturePath(aperture, camera, config, center, center);

  let svg = `<!-- Generated by OpticLab at ${dateStr} -->
<svg xmlns="http://www.w3.org/2000/svg" width="${sizeMm}mm" height="${sizeMm}mm" viewBox="0 0 ${sizeMm} ${sizeMm}">
    <defs>
      <style>
        .cut { fill: ${config.inverted ? 'black' : 'none'}; stroke: ${config.inverted ? 'none' : 'black'}; stroke-width: 0.05; vector-effect: non-scaling-stroke; fill-rule: evenodd; }
        .label { font-family: sans-serif; font-size: 2px; fill: #666; }
      </style>
    </defs>
    <title>${aperture.type} Aperture</title>
    <desc>Diameter: ${aperture.diameter}mm, Camera FL: ${camera.focalLength}mm</desc>
    ${config.showLabels ? `<text x="2" y="${sizeMm-2}" class="label">${aperture.type} ${aperture.diameter}mm</text>` : ''}
    <g transform="rotate(${aperture.rotation || 0}, ${center}, ${center})">
        ${content}
    </g>
</svg>`;
  return svg;
};

export const generateSheetSVG = (
    items: ProductionItem[],
    config: ExportConfig
): string => {
    const { sheetWidth, sheetHeight, spacing, plateType, nesting } = config;
    const itemW = config.itemSize;
    const itemH = (plateType === 'RECT' && config.itemHeight) ? config.itemHeight : config.itemSize;
    
    const dateStr = new Date().toISOString();
    
    // Style Definitions for Laser vs Print
    const isLaser = !config.inverted;
    
    // Laser: Red cut lines, Blue outlines. Background technically transparent but we'll handle that via CSS in preview.
    // Print: Black filled holes. White background.
    
    let styleBlock = '';
    if (isLaser) {
        styleBlock = `
          .cut { fill: none; stroke: #ff0000; stroke-width: 0.05; vector-effect: non-scaling-stroke; fill-rule: evenodd; }
          .outline { fill: none; stroke: #0000ff; stroke-width: 0.05; vector-effect: non-scaling-stroke; }
          .mark { fill: none; stroke: #000000; stroke-width: 0.1; }
          .label { font-family: sans-serif; font-size: 2px; fill: #666; }
        `;
    } else {
        styleBlock = `
          .cut { fill: black; stroke: none; fill-rule: evenodd; }
          .outline { fill: none; stroke: #ccc; stroke-width: 0.1; stroke-dasharray: 1 1; }
          .mark { stroke: #000; stroke-width: 0.2; }
          .label { font-family: sans-serif; font-size: 2px; fill: #666; }
        `;
    }

    let svg = `<!-- Generated by OpticLab Batch Mode at ${dateStr} -->
<svg xmlns="http://www.w3.org/2000/svg" width="${sheetWidth}mm" height="${sheetHeight}mm" viewBox="0 0 ${sheetWidth} ${sheetHeight}">
      <defs>
        <style>
          ${styleBlock}
        </style>
      </defs>
      <title>OpticLab Production Sheet</title>
      ${!isLaser ? `<rect width="100%" height="100%" fill="white" />` : ''} 
      `;

    // --- NESTING LOGIC ---
    let positions: {x: number, y: number}[] = [];
    
    if (nesting && plateType === 'CIRCLE') {
        // Hexagonal Packing / Staggered Grid for Circles
        const r = itemW / 2;
        const effW = itemW + spacing;
        const rowHeight = effW * Math.sin(Math.PI / 3); // approx 0.866 * effW
        
        let row = 0;
        let count = 0;
        
        while (count < items.length) {
            const y = spacing + r + row * rowHeight;
            if (y + r > sheetHeight) break; // Full height
            
            const isOdd = row % 2 !== 0;
            const xOffset = isOdd ? effW / 2 : 0;
            
            let col = 0;
            while (count < items.length) {
                const x = spacing + r + col * effW + xOffset;
                if (x + r > sheetWidth) break; // End of row
                
                positions.push({x, y});
                col++;
                count++;
            }
            row++;
        }
    } else {
        // Standard Grid (Square/Rect)
        const cols = Math.max(1, Math.floor((sheetWidth - spacing) / (itemW + spacing)));
        const rows = Math.max(1, Math.floor((sheetHeight - spacing) / (itemH + spacing)));
        const totalSlots = cols * rows;
        
        const usedWidth = cols * (itemW + spacing) - spacing;
        const usedHeight = rows * (itemH + spacing) - spacing;
        const marginX = Math.max(0, (sheetWidth - usedWidth) / 2);
        const marginY = Math.max(0, (sheetHeight - usedHeight) / 2);

        for (let i = 0; i < items.length && i < totalSlots; i++) {
            const r = Math.floor(i / cols);
            const c = i % cols;
            const x = marginX + c * (itemW + spacing) + itemW/2;
            const y = marginY + r * (itemH + spacing) + itemH/2;
            positions.push({x, y});
        }
    }

    // --- DRAW ITEMS ---
    positions.forEach((pos, i) => {
        const item = items[i];
        const {x, y} = pos;
        
        // Draw Plate Outline
        if (config.cutPlateOutline || !isLaser) {
            if (plateType === 'CIRCLE') {
                const r = itemW / 2;
                // For laser, cut outer edge. Apply OUTWARD kerf compensation if needed, but for plates we usually cut ON line or outward.
                // Standard practice: Blue line = Vector Cut (Outer). 
                // Let's blindly apply kerf/2 outward if requested? No, usually kerf is mostly for the HOLE precision.
                // We will leave plate outline nominal.
                svg += `<circle cx="${formatNum(x)}" cy="${formatNum(y)}" r="${formatNum(r)}" class="outline" />`;
            } else {
                svg += `<rect x="${formatNum(x - itemW/2)}" y="${formatNum(y - itemH/2)}" width="${formatNum(itemW)}" height="${formatNum(itemH)}" class="outline" />`;
            }
        } else {
            // Guide markers for laser if not cutting outline (e.g. alignment)
            // Just tiny corner ticks? Or nothing?
            // User requested "Cut marks at borders", which usually means sheet.
            // If we don't cut plate outline, we might want a visual guide?
            if (plateType === 'CIRCLE') {
                 svg += `<circle cx="${formatNum(x)}" cy="${formatNum(y)}" r="${formatNum(itemW/2)}" stroke="#333" stroke-width="0.05" stroke-dasharray="1 1" fill="none" />`;
            } else {
                 svg += `<rect x="${formatNum(x - itemW/2)}" y="${formatNum(y - itemH/2)}" width="${formatNum(itemW)}" height="${formatNum(itemH)}" stroke="#333" stroke-width="0.05" stroke-dasharray="1 1" fill="none" />`;
            }
        }
        
        // Label
        if (config.showLabels) {
            svg += `<text x="${(x - itemW/2 + 1).toFixed(2)}" y="${(y + itemH/2 - 1).toFixed(2)}" class="label">${item.name} (${item.camera.focalLength}mm)</text>`;
        }

        // Aperture
        svg += `<g transform="rotate(${item.aperture.rotation || 0}, ${x}, ${y})">`;
        svg += getAperturePath(item.aperture, item.camera, config, x, y);
        svg += `</g>`;
    });

    // --- CROP MARKS ---
    if (config.cutMarks) {
        const markLen = 5;
        const offset = 2;
        // TL
        svg += `<line x1="${offset}" y1="${offset}" x2="${offset+markLen}" y2="${offset}" class="mark" />`;
        svg += `<line x1="${offset}" y1="${offset}" x2="${offset}" y2="${offset+markLen}" class="mark" />`;
        // TR
        svg += `<line x1="${sheetWidth-offset}" y1="${offset}" x2="${sheetWidth-offset-markLen}" y2="${offset}" class="mark" />`;
        svg += `<line x1="${sheetWidth-offset}" y1="${offset}" x2="${sheetWidth-offset}" y2="${offset+markLen}" class="mark" />`;
        // BL
        svg += `<line x1="${offset}" y1="${sheetHeight-offset}" x2="${offset+markLen}" y2="${sheetHeight-offset}" class="mark" />`;
        svg += `<line x1="${offset}" y1="${sheetHeight-offset}" x2="${offset}" y2="${sheetHeight-offset-markLen}" class="mark" />`;
        // BR
        svg += `<line x1="${sheetWidth-offset}" y1="${sheetHeight-offset}" x2="${sheetWidth-offset-markLen}" y2="${sheetHeight-offset}" class="mark" />`;
        svg += `<line x1="${sheetWidth-offset}" y1="${sheetHeight-offset}" x2="${sheetWidth-offset}" y2="${sheetHeight-offset-markLen}" class="mark" />`;
    }
    
    svg += `</svg>`;
    return svg;
};

function getAperturePath(
    aperture: ApertureConfig, 
    camera: CameraConfig, 
    config: ExportConfig,
    centerX: number,
    centerY: number
): string {
    
    if (aperture.diameter <= 0) return "";

    const lambda = (camera.wavelength || 550) * 1e-6;
    const f = camera.focalLength || 50;
    let content = "";
    
    const useBridges = config.addBridges && !config.inverted;
    const kerf = Math.max(0, config.kerf || 0);

    // --- KERF COMPENSATED PRIMITIVES ---
    // For a hole, we need to cut slightly SMALLER than nominal so the laser kerf expands it to the correct size.
    // However, if the user gives `kerf` as the beam width:
    // Radius_cut = Radius_nominal - kerf/2
    // Width_cut = Width_nominal - kerf
    
    const addCircle = (cx: number, cy: number, r: number) => {
        const rCut = r - kerf/2;
        if (rCut <= 0) return; // Too small for kerf
        content += `<circle cx="${formatNum(cx)}" cy="${formatNum(cy)}" r="${formatNum(rCut)}" class="cut" />`;
    };
    
    const addRect = (cx: number, cy: number, w: number, h: number) => {
        const wCut = w - kerf;
        const hCut = h - kerf;
        if (wCut <= 0 || hCut <= 0) return;
        content += `<rect x="${formatNum(cx - wCut/2)}" y="${formatNum(cy - hCut/2)}" width="${formatNum(wCut)}" height="${formatNum(hCut)}" class="cut" />`;
    };

    // For complex paths (Polygon/Path), direct offset is hard without a library.
    // Fallback: Use stroke-width trick? No, laser follows center.
    // Approx for polygon: scale vertices towards center? 
    // We will apply simple scaling relative to center for now, or just warn user.
    // Implementation: simple scaling for Polygon.
    const addPolygon = (points: {x: number, y: number}[]) => {
        // Calculate centroid
        let cx = 0, cy = 0;
        points.forEach(p => { cx += p.x; cy += p.y; });
        cx /= points.length; cy /= points.length;
        
        // Very basic shrink
        // We assume roughly convex or simple shape.
        // For accurate offset we need a library (like Clipper).
        // Here we won't apply kerf to complex polygons to avoid artifacts, unless it's just 'PINHOLE' style.
        const pts = points.map(p => `${formatNum(p.x + centerX)},${formatNum(p.y + centerY)}`).join(" ");
        content += `<polygon points="${pts}" class="cut" />`;
    };

    const addPath = (d: string) => {
        content += `<path d="${d}" class="cut" />`;
    };

    const addStenciledCircle = (cx: number, cy: number, r: number, bridges: number = 3) => {
        const rCut = r - kerf/2;
        if (rCut <= 0) return;
        
        if (!useBridges) {
            content += `<circle cx="${formatNum(cx)}" cy="${formatNum(cy)}" r="${formatNum(rCut)}" class="cut" />`;
            return;
        }
        
        // Bridges need to be wider if kerf eats them?
        // Actually, bridges are gaps in the cut.
        // If we cut, the kerf eats into the bridge.
        // So bridge angle should be calculated based on (bridgeSize + kerf).
        const effBridgeSize = config.bridgeSizeMm + kerf;
        const bridgeAngle = effBridgeSize / rCut; // radians approx
        
        const step = (Math.PI * 2) / bridges;
        let d = "";
        for(let i=0; i<bridges; i++) {
            const startAngle = i * step + bridgeAngle/2;
            const endAngle = (i+1) * step - bridgeAngle/2;
            const x1 = cx + rCut * Math.cos(startAngle);
            const y1 = cy + rCut * Math.sin(startAngle);
            const x2 = cx + rCut * Math.cos(endAngle);
            const y2 = cy + rCut * Math.sin(endAngle);
            const largeArc = (endAngle - startAngle) > Math.PI ? 1 : 0;
            d += `M ${formatNum(x1)} ${formatNum(y1)} A ${formatNum(rCut)} ${formatNum(rCut)} 0 ${largeArc} 1 ${formatNum(x2)} ${formatNum(y2)} `;
        }
        addPath(d);
    };

    // Use if-else if structure to be 100% safe against switch scoping quirks
    if (aperture.type === ApertureType.PINHOLE) {
        addCircle(centerX, centerY, aperture.diameter / 2);
    } 
    else if (aperture.type === ApertureType.SLIT) {
        addRect(centerX, centerY, aperture.diameter || 5.0, aperture.slitWidth || 0.2);
    }
    else if (aperture.type === ApertureType.CROSS) {
        const w = aperture.slitWidth || 0.5;
        const len = aperture.diameter;
        addRect(centerX, centerY, w, len);
        addRect(centerX, centerY, len, w);
    }
    else if (aperture.type === ApertureType.ZIGZAG) {
         // Kerf not applied to path stroke logic yet, as it's single line cut usually?
         // If it's a slot, we should use addRect segments? 
         // Original ZIGZAG implementation used stroke.
         // For laser cutting a "line thickness" implies cutting a slot.
         // We should simulate the slot by drawing the outline of the zigzag.
         // Complex. Falling back to centerline cut for ZigZag if stroke mode?
         // Actually the previous code used <path stroke-width> which SVG export converts to just a line with thickness.
         // Laser cutters ignore stroke-width usually and cut the center.
         // To cut a slot of width X, we must draw the boundary.
         // RE-IMPLEMENTING ZIGZAG as outline for proper cutting would be ideal but complex.
         // Leaving as centerline for now, user manually handles width via laser settings if single line.
         // IF 'LINED' polygon or path, usually means vector cut on center.
         
         const width = aperture.diameter || 5;
         const height = aperture.slitHeight || 2.0;
         const segments = Math.max(1, aperture.count || 5);
         
         const stepX = width / segments;
         const startX = centerX - width / 2;
         
         let d = `M ${formatNum(startX)} ${formatNum(centerY + height/2)} `;
         for(let i=1; i<=segments; i++) {
             const x = startX + i * stepX;
             const y = centerY + ((i % 2 === 0) ? height/2 : -height/2);
             d += `L ${formatNum(x)} ${formatNum(y)} `;
         }
         // Note: Kerf not applied to single-stroke paths
         content += `<path d="${d}" fill="none" stroke="red" stroke-width="0.05" />`;
    }
    else if (aperture.type === ApertureType.DOT_SLIT) {
         const dotR = (aperture.innerDiameter || 0.2) / 2;
         const slitW = aperture.slitWidth || 0.2;
         const slitL = aperture.diameter || 5;
         const dist = aperture.spread || 1.0;
         addCircle(centerX - dist/2, centerY, dotR);
         addRect(centerX + dist/2, centerY, slitW, slitL);
    }
    else if (aperture.type === ApertureType.LITHO_OPC) {
         const featureLen = (aperture.diameter || 2.0);
         const featureWid = (featureLen * 0.2); 
         const srafDist = (aperture.slitWidth || 0.05) * 2; 
         const srafWid = (aperture.slitWidth || 0.05);
         addRect(centerX, centerY, featureLen, featureWid);
         const headSize = featureWid * 1.5;
         addRect(centerX - featureLen/2 + headSize/2, centerY, headSize, headSize);
         addRect(centerX + featureLen/2 - headSize/2, centerY, headSize, headSize);
         addRect(centerX, centerY - headSize/2 - srafDist - srafWid/2, featureLen, srafWid);
         addRect(centerX, centerY + headSize/2 + srafDist + srafWid/2, featureLen, srafWid);
    }
    else if (aperture.type === ApertureType.ZONE_PLATE) {
        const maxR_mm = aperture.diameter / 2;
        const maxN = Math.floor(Math.pow(maxR_mm, 2) / (lambda * f));
        for (let n = Math.max(1, maxN); n >= 1; n--) {
             const r_mm = Math.sqrt(n * lambda * f);
             if (n % 2 === 1) {
                addStenciledCircle(centerX, centerY, r_mm, 3);
             }
        }
    }
    else if (aperture.type === ApertureType.ANNULAR) {
        const rOut = aperture.diameter / 2;
        const rIn = rOut * 0.6;
        if (config.inverted) {
            // Print mode (Negative) - Kerf not strictly needed for printing but good for consistency? Usually irrelevant.
            const path = `M ${formatNum(centerX - rOut)} ${formatNum(centerY)} ` +
                         `A ${formatNum(rOut)} ${formatNum(rOut)} 0 1 0 ${formatNum(centerX + rOut)} ${formatNum(centerY)} ` +
                         `A ${formatNum(rOut)} ${formatNum(rOut)} 0 1 0 ${formatNum(centerX - rOut)} ${formatNum(centerY)} ` +
                         `M ${formatNum(centerX - rIn)} ${formatNum(centerY)} ` +
                         `A ${formatNum(rIn)} ${formatNum(rIn)} 0 1 1 ${formatNum(centerX + rIn)} ${formatNum(centerY)} ` +
                         `A ${formatNum(rIn)} ${formatNum(rIn)} 0 1 1 ${formatNum(centerX - rIn)} ${formatNum(centerY)} Z`;
            addPath(path);
        } else {
            addStenciledCircle(centerX, centerY, rOut, 3);
            addStenciledCircle(centerX, centerY, rIn, 3);
        }
    }
    else if (aperture.type === ApertureType.MULTI_DOT) {
        const pattern = aperture.multiDotPattern || MultiDotPattern.RING;
        const count = Math.max(1, aperture.count || 8);
        const spread = (aperture.spread || 2.0);
        const dotR = (aperture.diameter || 0.2) / 2;
        let mRng = aperture.seed || 123;
        const rand = () => { mRng = (mRng * 1664525 + 1013904223) % 4294967296; return mRng / 4294967296; };

        if (aperture.centerDot) {
             addCircle(centerX, centerY, dotR);
        }

        if (pattern === MultiDotPattern.RING) {
            for(let i=0; i<count; i++) {
              const theta = (i / count) * Math.PI * 2;
              addCircle(centerX + spread*Math.cos(theta), centerY + spread*Math.sin(theta), dotR);
            }
        } else if (pattern === MultiDotPattern.LINE) {
            const startX = -spread;
            const step = count > 1 ? (spread * 2) / (count - 1) : 0;
            for(let i=0; i<count; i++) {
              addCircle(centerX + startX + i*step, centerY, dotR);
            }
        } else if (pattern === MultiDotPattern.GRID) {
            const side = Math.ceil(Math.sqrt(count));
            const spacing = (spread * 2) / Math.max(1, side - 1);
            const offset = spread;
            let drawn = 0;
            for(let r=0; r<side; r++) {
              for(let c=0; c<side; c++) {
                if(drawn >= count) break;
                addCircle(centerX + c*spacing - offset, centerY + r*spacing - offset, dotR);
                drawn++;
              }
            }
        } else if (pattern === MultiDotPattern.CONCENTRIC) {
            const rings = 5;
            const perRing = Math.ceil(count / rings);
            for(let r=1; r<=rings; r++) {
              const rad = (r/rings) * spread;
              for(let k=0; k<perRing; k++) {
                const a = (k/perRing) * Math.PI*2;
                addCircle(centerX + rad*Math.cos(a), centerY + rad*Math.sin(a), dotR);
              }
            }
        } else if (pattern === MultiDotPattern.RANDOM) {
            for(let i=0; i<count; i++) {
              const r = spread * Math.sqrt(rand());
              const th = 2 * Math.PI * rand();
              addCircle(centerX + r*Math.cos(th), centerY + r*Math.sin(th), dotR);
            }
        }
    }
    else if (aperture.type === ApertureType.FIBONACCI) {
        const points = Math.max(1, aperture.count || 50);
        const maxRad = aperture.spread || 2.0;
        const fDotR = (aperture.diameter || 0.1) / 2;
        const goldenAngle = Math.PI * (3 - Math.sqrt(5)); 
        for (let i = 0; i < points; i++) {
           const r = maxRad * Math.sqrt(i / points);
           const theta = i * goldenAngle;
           addCircle(centerX + r * Math.cos(theta), centerY + r * Math.sin(theta), fDotR);
        }
    }
    else if (aperture.type === ApertureType.PHOTON_SIEVE) {
         const sieveZones = aperture.zones || 15;
         let rng = aperture.seed || 12345;
         const nextRnd = () => { rng = (rng * 1664525 + 1013904223) % 4294967296; return rng / 4294967296; };
         const maxSieveR = aperture.diameter / 2;
         for (let n = 1; n <= sieveZones * 2; n += 2) {
             const r_center_mm = Math.sqrt((n + 0.5) * lambda * f);
             const r_width_mm = Math.sqrt((n + 1) * lambda * f) - Math.sqrt(n * lambda * f);
             if (r_center_mm > maxSieveR) break;
             
             const hole_d = 1.53 * r_width_mm;
             if (hole_d <= 0.001) continue; 
             
             const circumference = 2 * Math.PI * r_center_mm;
             const numHoles = Math.floor((circumference / (hole_d * 1.5)));
             
             for(let k=0; k<numHoles; k++) {
                 const theta = (k / numHoles) * Math.PI * 2 + (nextRnd() * 0.5);
                 addCircle(centerX + r_center_mm*Math.cos(theta), centerY + r_center_mm*Math.sin(theta), hole_d/2);
             }
         }
    }
    else if (aperture.type === ApertureType.RANDOM) {
        const rRadius = aperture.diameter / 2;
        let rRng = 999;
        const rNext = () => { rRng = (rRng * 9301 + 49297) % 233280; return rRng / 233280; };
        for(let i=0; i<300; i++) {
            const r = rRadius * Math.sqrt(rNext());
            const th = 2 * Math.PI * rNext();
            const s = (0.05) * (0.5 + rNext()); 
            addCircle(centerX + r*Math.cos(th), centerY + r*Math.sin(th), s);
        }
    }
    else {
         // Default Fallback
         addCircle(centerX, centerY, aperture.diameter/2);
    }

    return content;
}
